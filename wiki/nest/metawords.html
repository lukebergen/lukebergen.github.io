<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>metawords</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<h1 id="nest">Nest</h1>
<h2 id="metawords">Metawords</h2>
<p>If you’ve read through <a href="grammar">grammar</a> then you
understand this idea of words taking in values and then resolving into
values which can then feed into other words and etc…</p>
<p>There are a few cases where we don’t want for a word to resolve into
a value because we want to do something meta-linguistic like quoting
text or saying something about the text itself without having it go off
trying to turn into a value.</p>
<p>For example, if I wanted to say “my name is Alice”, we don’t want to
rely on listeners implicitly understanding that some words aren’t really
<em>words</em> like from a dictionary. They’re more like labels. Enter
<code>zu*</code>.</p>
<p>zu* x = “$x”</p>
<p>“*” like that, know that we’re defining a metaword and that usual
rules get a little unusual. The right-hand side of the “=” will often
just be text describing what the heck a reader should do if they
encounter this word rather than the usual “relate the values to each
other”.</p>
<p>Here the “x”, “y”, and “z” often refers to the unresolved words that
follow rather than resolved ones. For example.</p>
<ul>
<li>Alice: She said zu hi (she said “hi”)</li>
</ul>
<p>Not… especially useful. Let’s look at another one.</p>
<p>li* x = the thing named $x</p>
<ul>
<li>Alice: <code>sonda mi ti li paul</code> (I gave this to Paul)</li>
</ul>
<p>When we were using Englishy sentences sprinkled with Nest, this
wasn’t necessary since English readers would see “Paul” and know that
we’re not talking about the literal text ‘Paul’ or some word ‘Paul’ that
has some meaning in a dictionary”. Rather, “Paul” is a label that refers
to something. <code>li paul</code> is a way to say “the thing we refer
to by”paul”.</p>
<p>In this way, <code>li x</code> is very <em>very</em> similar to <a
href="references">references</a>. In fact, they are exactly the same
thing. <code>ly</code> and <code>li ly</code> mean the same thing and
could be used interchangably. They both refer to some thing labeled as
“ly” that members of the conversation understand from shared <a
href="context">context</a> what we’re talking about.</p>
</body>
</html>
